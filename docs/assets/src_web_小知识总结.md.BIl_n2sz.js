import{_ as s,c as i,o as e,ag as t}from"./chunks/framework.CbHz3_YU.js";const r="/site-blog/assets/defer.D-NSrJNr.jpeg",g=JSON.parse('{"title":"边角知识","description":"","frontmatter":{},"headers":[],"relativePath":"src/web/小知识总结.md","filePath":"src/web/小知识总结.md","lastUpdated":1769161902000}'),n={name:"src/web/小知识总结.md"};function o(p,a,l,h,d,c){return e(),i("div",null,[...a[0]||(a[0]=[t('<h1 id="边角知识" tabindex="-1">边角知识 <a class="header-anchor" href="#边角知识" aria-label="Permalink to &quot;边角知识&quot;">​</a></h1><h2 id="seo-搜索引擎优化" tabindex="-1">SEO(搜索引擎优化) <a class="header-anchor" href="#seo-搜索引擎优化" aria-label="Permalink to &quot;SEO(搜索引擎优化)&quot;">​</a></h2><p>SEO(Search Engine Optimization)是搜索引擎对网站的排名和收录的过程，通过对网站的页面内容、链接、关键字、标题、图片等进行优化，<strong>提升网站在搜索引擎的排名</strong>，从而提高网站的流量。</p><p>其中Next.js在SEO方面表现出色</p><ul><li>黑帽SEO(非人手段提升SEO)：通常指的是使用违反搜索引擎规则的技术手段来提升网站排名。<strong>(关键词滥用)</strong></li><li>白帽SEO：遵循搜索引擎的规则进行优化，注重网站内容的质量，通过提高网站的用户体验来赢得更好的排名。</li></ul><h2 id="tdk-title-description-keywords" tabindex="-1">TDK(Title Description Keywords) <a class="header-anchor" href="#tdk-title-description-keywords" aria-label="Permalink to &quot;TDK(Title Description Keywords)&quot;">​</a></h2><p>Title Description Keywords</p><p>Next.js支持自定义这些TDK元素，可以通过使用组件来设置每个页面的标题、描述和关键词，从而更好地进行SEO优化。</p><h2 id="ssg-spa-ssr" tabindex="-1">SSG SPA SSR <a class="header-anchor" href="#ssg-spa-ssr" aria-label="Permalink to &quot;SSG SPA SSR&quot;">​</a></h2><p>SSG(Static Site Generator)是一种Web应用程序的开发模式，服务器端生成<strong>静态</strong>HTML页面，浏览器直接加载静态页面，实现页面的快速加载。代表有：Vitepress AStro 主要用于 官网 营销页 博客 技术文档</p><p>SPA(Single Page Application)是一种Web应用程序的开发模式，整个页面由一个HTML文件和JavaScript脚本构成，通过JavaScript<strong>动态</strong>更新页面内容，实现用户与应用的交互。</p><p>SSR(Server-Side Rendering) = SPA + SSG</p><h2 id="事件代理" tabindex="-1">事件代理 <a class="header-anchor" href="#事件代理" aria-label="Permalink to &quot;事件代理&quot;">​</a></h2><p>事件代理（Event Delegation）是一种在JavaScript中处理多个事件监听器的方法。它是一种利用<strong>事件冒泡机制</strong>的编程模式，将事件监听器添加到父元素上，而不是直接添加到每个子元素上，通过判断事件的目标元素来执行相应的操作。其核心原理是：<strong>基于 DOM 事件流的冒泡阶段</strong>：当子元素触发事件时，事件会向上冒泡到父元素。</p><h2 id="回流与重回" tabindex="-1">回流与重回 <a class="header-anchor" href="#回流与重回" aria-label="Permalink to &quot;回流与重回&quot;">​</a></h2><p>回流（Reflow）：改变布局 → 重新计算 → 重新渲染 重绘（Repaint）：改变样式 → 重新绘制</p><p><strong>回流必定引起重绘，但重绘不一定引起回流</strong></p><h2 id="defer-和-async" tabindex="-1">defer 和 async <a class="header-anchor" href="#defer-和-async" aria-label="Permalink to &quot;defer 和 async&quot;">​</a></h2><p><img src="'+r+`" alt="defer"></p><h2 id="import-a-from-c-和-import-b-from-c-有什么区别" tabindex="-1"><code>import A from &#39;C&#39;</code>和 <code>import { B } from &#39;C&#39;</code> 有什么区别? <a class="header-anchor" href="#import-a-from-c-和-import-b-from-c-有什么区别" aria-label="Permalink to &quot;\`import A from &#39;C&#39;\`和 \`import { B } from &#39;C&#39;\` 有什么区别?&quot;">​</a></h2><p><code>import A from &#39;C&#39;</code> 导入的是模块 C 的默认导出（export default），A 是你给它起的任意名字。</p><p><code>import { B } from &#39;C&#39;</code> 导入的是模块 C 的具名导出（export），B 必须和导出时的名字一致。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// C.js</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> default</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {} </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 默认导出</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> bar</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {}         </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 具名导出</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 导入侧</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Whatever </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;C&#39;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Whatever === foo，名字随便取</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { bar } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;C&#39;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     // 必须叫 bar，除非用 as 重命名：import { bar as baz } from &#39;C&#39;</span></span></code></pre></div><ul><li>一个模块只能有一个 <code>export default</code>，但可以有多个 <code>export</code>。</li><li>默认导出本质上是一个名为 <code>default</code> 的具名导出，所以 <code>import { default as A } from &#39;C&#39;</code> 等价于 <code>import A from &#39;C&#39;</code>。</li><li>两者可以混用：<code>import A, { B } from &#39;C&#39;</code>。</li></ul>`,24)])])}const m=s(n,[["render",o]]);export{g as __pageData,m as default};
