import{_ as l,C as r,c as i,o as a,j as o,ag as t,a as d,G as s}from"./chunks/framework.CbHz3_YU.js";const _=JSON.parse('{"title":"docker","description":"","frontmatter":{},"headers":[],"relativePath":"src/backend/中间件/docker.md","filePath":"src/backend/中间件/docker.md","lastUpdated":1769161902000}'),n={name:"src/backend/中间件/docker.md"},k={id:"docker",tabindex:"-1"};function u(p,e,m,h,X,b){const c=r("Badge");return a(),i("div",null,[o("h1",k,[e[0]||(e[0]=d("docker ",-1)),s(c,{type:"warning",text:"总结于三更草堂的docker课程"}),e[1]||(e[1]=d()),e[2]||(e[2]=o("a",{class:"header-anchor",href:"#docker","aria-label":'Permalink to "docker <Badge type="warning" text="总结于三更草堂的docker课程" />"'},"​",-1))]),e[3]||(e[3]=t('<h2 id="容器基本命令" tabindex="-1">容器基本命令 <a class="header-anchor" href="#容器基本命令" aria-label="Permalink to &quot;容器基本命令&quot;">​</a></h2><ol><li>找<strong>镜像</strong>：dockerhub：<a href="https://hub.docker.com/" target="_blank" rel="noreferrer">https://hub.docker.com/</a></li><li>下载<strong>镜像</strong>：<code>docker pull XXX:版本</code> 例如：<code>docker pull mysql:latest</code> <strong>注意版本！！！ 注意版本！！！ 注意版本！！！</strong></li><li>查看本地有哪些镜像 <code>docker images</code></li><li>查看运行时的容器</li></ol><ul><li><code>docker ps </code></li><li><code>docker ps -a</code></li></ul><ol start="5"><li>创建并运行容器 <code>docker run XXX</code> 例如：<code>docker run nginx:latest</code><ul><li>后台运行 <code>docker run -d XXX </code></li><li>交互式运行 <code>docker run -it XXX</code></li></ul></li><li>删除容器 <code>docker rm XXX</code> (运行时容器不能删除 可以通过添加参数进行删除)</li><li>进入容器内执行命令 <code>docker exec XXXid</code> 命令 <ul><li>交互式 <code>docker exec -it XXXid bash</code></li></ul></li><li>查看容器日志 <code>docker logs XXXid </code><ul><li>持续输出日志 <code>docker logs -f XXXid </code></li></ul></li><li>停止容器 <code>docker stop XXXid</code></li><li>运行容器 <code>docker start XXXid </code></li></ol><div class="tip custom-block"><p class="custom-block-title">请解决一下问题？</p><ol><li>如何找到需要发布的端口？</li><li>如何知道需要挂载的目录？</li></ol></div><h2 id="run命令详解" tabindex="-1">run命令详解 <a class="header-anchor" href="#run命令详解" aria-label="Permalink to &quot;run命令详解&quot;">​</a></h2><ol><li><code>-p</code> 端口映射 默认容器端口和宿主机端口不连通 <code>docker run -p 宿主机端口:容器端口</code> 若想发布多个端口 <code>docker run -p 宿主机端口1:容器端口1 -p 宿主机端口2:容器端口2</code></li><li><code>-v</code> 数据卷 用于宿主机和容器之间的 数据共享（同步）<code>docker run -v 宿主机目录:容器目录</code></li><li><code>-e</code> 设置环境变量 （某些变量不能写死 比如Mysql的root密码） <code>docker run -e 变量名=变量值 容器名</code></li><li><code>--name</code> 给容器命名 <code>docker run --name 定义的容器名 镜像名</code></li><li><code>--restart</code> 重启策略 用于容器或者宿主机因某些情况重启后 容器能够重新启动</li></ol><h2 id="数据卷高级" tabindex="-1">数据卷高级 <a class="header-anchor" href="#数据卷高级" aria-label="Permalink to &quot;数据卷高级&quot;">​</a></h2><ol><li>别名 <code>docker run -v 别名:容器目录 镜像名</code> 这样不需要再写宿主机目录 直接用别名代替 docker会自己在宿主机创建一个目录</li><li>创建数据卷 <code>docker volume create XXX</code> (用的不多)</li><li>删除数据卷 <code>docker volume rm XXX</code> (用的不多)</li><li>eg:创建Mysql脚本 <code>docker run -d -v mysql_data:/var/lib/mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=root --restart always --name blog_mysql mysql:5.7</code></li><li>eg:创建Redis脚本 <code>docker run -d -v redis_data:/data -p 6379:6379 --restart always --name blog_redis redis:7.0 redis-server --appendonly yes</code></li><li>eg:上传项目 <code>docker run -d -p 7777:7777 -v /usr/blog:/usr/blog --restart always --name sg_blog java:openjdk-8u111 java -jar /usr/blog/sangeng-blog-1.0-SNAPSHOT.jar</code><br> 排查问题 <code>docker run -it -p 7777:7777 -v /usr/blog:/usr/blog --restart always --name sg_blog java:openjdk-8u111 bush</code></li></ol><h2 id="docker网络" tabindex="-1">Docker网络 <a class="header-anchor" href="#docker网络" aria-label="Permalink to &quot;Docker网络&quot;">​</a></h2><ol><li>创建网络 <code>docker network create 网络名</code></li><li>列出网络 <code>docker network ls</code></li><li>加入网络 <ul><li>创建时加入 <code>docker run --network 网络名 镜像名 </code></li><li>创建后加入 <code>docker network connect 网络名 容器名/XXXid</code></li></ul></li><li>查看网络详情 <code>docker network inspect 网络名\\id</code></li><li>删除网络 <code>docker network rm 网络名\\id</code></li></ol><h2 id="dockerfile-用于构建镜像" tabindex="-1">DockerFile（用于构建镜像） <a class="header-anchor" href="#dockerfile-用于构建镜像" aria-label="Permalink to &quot;DockerFile（用于构建镜像）&quot;">​</a></h2><ol><li>构建镜像 <code>docker build -t 镜像名:镜像标签 -f 基于的DockerFile文件的文件名 DockerFile文件路径</code> eg: <code>docker build -t hello:1.0 -f helloworld .</code></li><li><code>FROM</code> 定义基础镜像 <code>FROM 镜像名:标签名</code> eg: <code>FROM centos:7</code></li><li><code>CMD</code> 容器 运行时 的默认命令 可以被<code>docker run</code>后面的命令覆盖 作用时机为：<strong>容器运行的时候</strong></li><li><code>ENV</code> 用于定义环境变量 <code>ENV 变量名=&quot;变量值&quot;</code></li><li><code>WORKDIR</code> 用于设置当前的工作目录 如果该目录不存在则自动创建（若文件在OSS等网络路径 则可能不会解压 拿不准就自己调试）</li><li><code>RUN</code> 构建时使用的命令</li><li><code>ADD</code> 把构建上下文或者网络文件添加到镜像中 如果文件是压缩包会自动解压</li><li><code>EXPOSE</code> 声明 开放端口(可以有多个) 只是声明 运行时仍需要使用<code>dockers run -p XXX:XXX</code></li><li><code>COPY</code> 从构建上下文中复制内容到镜像中 (COPY仅仅只是复制 单纯的拷贝)</li><li><code>ENTRYPOINT</code> 用来定义容器运行时的默认命令 <code>docker run</code> 时无法覆盖<code>ENTRYPOINT</code>里的内容</li></ol><h2 id="dockercompose-用于启动服务" tabindex="-1">DockerCompose（用于启动服务） <a class="header-anchor" href="#dockercompose-用于启动服务" aria-label="Permalink to &quot;DockerCompose（用于启动服务）&quot;">​</a></h2><ol><li>DockerCompose是用来定义一个或者多个容器运行和应用的工具</li><li>使用<code>yaml</code>文件编写（可以使用IDEA 有插件）</li><li>查看版本 <code>docker compose version</code></li><li>运行 <code>docker compose up</code> <code>(docker compose up -d)</code></li><li>停止 <code>docker compose down </code></li><li>常用元素： <ul><li>command 覆盖容器启动后的默认命令</li><li>environment 指定环境变量 <code>(docker run -e)</code></li><li>image 指定镜像</li><li>networks 指定网络 <code>(docker run --network)</code></li><li>ports 指定发布端口 <code>(docker run -p)</code></li><li>volumes 指定数据卷 <code>(docker run -v)</code></li><li>restart 指定重启策略 <code>(docker run --restart)</code></li></ul></li></ol><h2 id="问题" tabindex="-1">问题 <a class="header-anchor" href="#问题" aria-label="Permalink to &quot;问题&quot;">​</a></h2><p>如何理解Dockerfile和DockerCompose？</p><p><a href="https://blog.csdn.net/londa/article/details/91815208" target="_blank" rel="noreferrer">https://blog.csdn.net/londa/article/details/91815208</a></p>',18))])}const f=l(n,[["render",u]]);export{_ as __pageData,f as default};
